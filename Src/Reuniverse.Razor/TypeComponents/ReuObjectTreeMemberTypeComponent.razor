@inherits TypeComponentBase<ReuObjectTreeMember>
@inject IJSRuntime JS

@if (!HideType)
{
    <div class="box type">
        <ReuFriendlyType Type="Value.Property.PropertyType" OnClick="OnTypeClick"></ReuFriendlyType>
        @if (!Value.Property.PropertyType.IsValueType && new NullabilityInfoContext().Create(Value.Property).ReadState is NullabilityState.Nullable)
        {
            <span>?</span>
        }
    </div>
}
<div class="box general">@Value.Property.Name</div>
@if (IsExpandable)
{
    <div @onclick="OnExpandToggle" class="box general expander @(IsExpanded ? "active" : "")">
        @(IsExpanded ? "▼" : "▶")
    </div>
}
@try
{
    @if (Value.Value is null)
    {
        @if (CanCreateInstance())
        {
            <span class="box-value clickable"
                  @onclick="CreateInstance"
                  @onmouseenter="@(args => ReuTooltip.ShowGlobal(args, "Create a new instance"))"
                  @onmousemove="ReuTooltip.MoveGlobal"
                  @onmouseout="ReuTooltip.HideGlobal">null</span>
        }
        else
        {
            <span class="box-value">null</span>
        }
    }
    else if (TryGetValueComponent(out var componentType))
    {
        var parameters = new Dictionary<string, object?>
        {
            ["Member"] = Value,
            ["ValueChanged"] = EventCallback.Factory.Create(this, ValueChanged)
        };

        <DynamicComponent Type="componentType" Parameters="parameters" />
    }
    else 
    {
        <span class="box-value">@Value.Value</span>
    }

    @if (CanRemoveValue())
    {
        <span class="box-value clickable remove"
              @onclick="RemoveValueAsync"
              @onmouseenter="@(args => ReuTooltip.ShowGlobal(args, "Set to null"))"
              @onmousemove="ReuTooltip.MoveGlobal"
              @onmouseout="ReuTooltip.HideGlobal">✕</span>
    }

    @if (prevValue is not null)
    {
        <span class="box-value clickable" @onclick="RevertValueAsync">Revert</span>
    }
}
catch (Exception ex)
{
    Exception = ex.InnerException ?? ex;
}
@if (Exception is not null)
{
    <div class="box-value error">@Exception.Message</div>
}

@if (!HideType && IsDifferentType(out var actualType))
{
    <span class="box-value type"><ReuFriendlyType Type="actualType" OnClick="OnTypeClick"></ReuFriendlyType></span>
}

@code {
    // this prevValue will be forgotten after the component is recreated, prefer storing it in separate class (not ReuObjectTreeMember as that one recreates too)
    private object? prevValue;

    public Exception? Exception { get; set; }

    private bool TryGetValueComponent(out Type? componentType)
    {
        var type = Value.Value?.GetType() ?? Value.Property.PropertyType;

        if (type.IsEnum)
        {
            componentType = typeof(EnumTypeValueComponent);
            return true;
        }

        if (Value.Value is IEnumerable<object> or System.Collections.ICollection)
        {
            componentType = typeof(EnumerableTypeValueComponent);
            return true;
        }

        return TypeValueComponents.TryGetValue(type, out componentType);
    }

    private bool CanCreateInstance()
    {
        if (Value.Property.SetMethod is null)
        {
            return false;
        }

        var propertyType = Value.Property.PropertyType;

        // Handle nullable types
        if (Nullable.GetUnderlyingType(propertyType) is Type underlyingType)
        {
            propertyType = underlyingType;
        }

        // Check if it has a parameterless constructor
        return !propertyType.IsAbstract && 
               !propertyType.IsInterface && 
               propertyType.GetConstructor(Type.EmptyTypes) is not null;
    }

    private async Task CreateInstance()
    {
        if (!CanCreateInstance() || Value.Property.SetMethod is null)
        {
            return;
        }

        try
        {
            var propertyType = Value.Property.PropertyType;

            // Handle nullable types
            if (Nullable.GetUnderlyingType(propertyType) is Type underlyingType)
            {
                propertyType = underlyingType;
            }

            var newInstance = Activator.CreateInstance(propertyType);
            Value.Property.SetValue(Value.Parent, newInstance);

            await ValueChanged.InvokeAsync();
            ReuTooltip.HideGlobal();
        }
        catch (Exception ex)
        {
            Exception = ex;
        }
    }

    private bool CanRemoveValue()
    {
        if (Value.Property.SetMethod is null || Value.Value is null)
        {
            return false;
        }

        var propertyType = Value.Property.PropertyType;

        // Can remove only if it's a nullable reference type
        if (propertyType.IsValueType)
        {
            // Only allow removing nullable value types (like int?, DateTime?)
            return Nullable.GetUnderlyingType(propertyType) is not null;
        }

        // For reference types, check if it's nullable using NullabilityInfo
        var nullabilityInfo = new NullabilityInfoContext().Create(Value.Property);
        return nullabilityInfo.WriteState is NullabilityState.Nullable;
    }

    private async Task RemoveValueAsync()
    {
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to set '{Value.Property.Name}' to null?");

        if (!confirmed)
        {
            return;
        }

        if (!CanRemoveValue())
        {
            return;
        }

        await SetValueAsync(null);
    }

    private bool IsDifferentType([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out Type? actualType)
    {
        if (Value.Value is null)
        {
            actualType = null;
            return false;
        }

        var propertyType = Value.Property.PropertyType;
        actualType = Value.Value.GetType();

        // Check if property type is nullable and actual type is the underlying type
        var underlyingType = Nullable.GetUnderlyingType(propertyType);

        if (underlyingType is not null && underlyingType == actualType)
        {
            return false;
        }

        return propertyType != actualType;
    }

    private async Task RevertValueAsync()
    {
        if (prevValue is null)
        {
            return;
        }
        
        await SetValueAsync(prevValue);
    }

    private async Task SetValueAsync(object? value)
    {
        if (Value.Property.SetMethod is null)
        {
            return;
        }

        var prevPrevValue = prevValue;
        prevValue = Value.Value;

        try
        {
            Value.Property.SetValue(Value.Parent, value);
            await ValueChanged.InvokeAsync();
            ReuTooltip.HideGlobal();
        }
        catch (TargetInvocationException ex)
        {
            Exception = ex;
            prevValue = prevPrevValue;
        }
    }
}
