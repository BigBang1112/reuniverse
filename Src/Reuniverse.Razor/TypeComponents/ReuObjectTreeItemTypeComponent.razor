@inherits TypeComponentBase<ReuObjectTreeItem>
@inject IJSRuntime JS

@if (!HideType && Value.Value is not null)
{
    <div class="box type">
        <ReuFriendlyType Type="Value.Value.GetType()" OnClick="OnTypeClick"></ReuFriendlyType>
    </div>
}
<code class="box general">#@Value.Index</code>
@if (IsExpandable)
{
    <div @onclick="OnExpandToggle" class="box general expander @(IsExpanded ? "active" : "")">
        @(IsExpanded ? "▼" : "▶")
    </div>
}
@if (Value.Value is null)
{
    <span class="box-value">null</span>
}
else if (TryGetValueComponent(out var componentType))
{
    var parameters = new Dictionary<string, object?>
    {
        ["Item"] = Value,
        ["ValueChanged"] = EventCallback.Factory.Create(this, ValueChanged)
    };

    <DynamicComponent Type="componentType" Parameters="parameters" />
}
else
{
    <span class="box-value">@Value.Value</span>
}
@if (CanRemoveValue())
{
    <span class="box-value clickable remove"
          @onclick="RemoveValueAsync"
          @onmouseenter="@(args => ReuTooltip.ShowGlobal(args, "Remove element"))"
          @onmousemove="ReuTooltip.MoveGlobal"
          @onmouseout="ReuTooltip.HideGlobal">✕</span>
}
@if (Exception is not null)
{
    <div class="box-value error">
        @Exception.Message
    </div>
}

@code {
    public Exception? Exception { get; set; }

    private bool TryGetValueComponent(out Type? componentType)
    {
        if (Value.Value is null)
        {
            componentType = null;
            return false;
        }

        var type = Value.Value.GetType();

        if (type.IsEnum)
        {
            componentType = typeof(EnumTypeValueComponent);
            return true;
        }

        if (Value.Value is IEnumerable<object>)
        {
            componentType = typeof(EnumerableTypeValueComponent);
            return true;
        }

        return TypeValueComponents.TryGetValue(type, out componentType);
    }

    private bool CanRemoveValue()
    {
        return Value.Parent is System.Collections.IList and not Array;
    }

    private async Task RemoveValueAsync()
    {
        if (Value.Parent is not System.Collections.IList list)
        {
            return;
        }

        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to remove #{Value.Index}?");

        if (!confirmed)
        {
            return;
        }

        try
        {
            list.RemoveAt(Value.Index);
            await ValueChanged.InvokeAsync(Value);
        }
        catch (Exception ex)
        {
            Exception = ex;
        }
    }
}
