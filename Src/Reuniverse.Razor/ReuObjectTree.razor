<div>
    <div class="item @(ParentTree is null ? "root" : "")">
        @if (Value is null)
        {
            <span class="box-value">null</span>
        }
        else if (TypeComponents.TryGetValue(Value.GetType(), out var componentType))
        {
            var parameters = new Dictionary<string, object>
            {
                ["Value"] = Value,
                ["TypeValueComponents"] = TypeValueComponents,
                ["IsExpandable"] = IsExpandable,
                ["IsExpanded"] = IsExpanded,
                ["OnExpandToggle"] = EventCallback.Factory.Create(this, ToggleExpanded),
                ["HideType"] = HideType,
                ["OnTypeClick"] = OnTypeClick,
                ["ValueChanged"] = EventCallback.Factory.Create(this, OnValueChange),
                ["OnSelect"] = EventCallback.Factory.Create(this, SelectAsync),
                ["Selected"] = SelectedObject?.Equals(Value) ?? false,
            };

            <DynamicComponent Type="componentType" Parameters="parameters" />
        }
        else
        {
            @if (!HideType)
            {
                <div class="box type">
                    <ReuFriendlyType Type="Value.GetType()" OnClick="OnTypeClick"></ReuFriendlyType>
                </div>
            }
            <div class="box general @(SelectedObject?.Equals(Value) == true ? "active" : "")" @onclick="() => SelectAsync(Value)">@(DisplayName ?? Value.ToString())</div>

            @if (IsExpandable)
            {
                <div @onclick="ToggleExpanded" class="box general expander @(IsExpanded ? "active" : "")">
                    @(IsExpanded ? "▼" : "▶")
                </div>
            }
        }

        @if (Exception is not null)
        {
            <div class="exception">@Exception.Message</div>
        }
    </div>
    @if (IsExpanded && Children.Any())
    {
        <div class="items">
            @foreach (var child in Children)
            {
                <ReuObjectTree Parent="Value"
                               ParentTree="this"
                               Value="child"
                               HideType="HideType"
                               OnTypeClick="OnTypeClick"
                               TypeComponents="TypeComponents"
                               TypeValueComponents="TypeValueComponents"
                               ChildrenProvider="ChildrenProvider"></ReuObjectTree>
            }
        </div>
    }
</div>

@code {
    private static HashSet<ExpandedObject> expandedObjects = new();
    private static HashSet<object> expansionPath = new();

    private ExpandedObject expandedObject = new();

    /// <summary>
    /// The object to display.
    /// </summary>
    [Parameter, EditorRequired]
    public object? Value { get; set; }

    /// <summary>
    /// Tracks the parent object of the current <see cref="Value"/>. Do not set unless you know what you are doing.
    /// </summary>
    [Parameter]
    public object? Parent { get; set; }

    /// <summary>
    /// Tracks the parent ReuObjectTree, used to reliably send state changes. Do not set unless you know what you are doing.
    /// </summary>
    [Parameter]
    public ReuObjectTree? ParentTree { get; set; }

    /// <summary>
    /// Any type to component type mapping to provide tree items. By default it uses <see cref="DefaultTypeComponents"/>, but you can override or extend it.
    /// </summary>
    [Parameter]
    public Dictionary<Type, Type> TypeComponents { get; set; } = DefaultTypeComponents;

    /// <summary>
    /// Any type to component type mapping to provide value rendering/editing. By default it uses <see cref="DefaultTypeValueComponents"/>, but you can override or extend it.
    /// </summary>
    [Parameter]
    public Dictionary<Type, Type> TypeValueComponents { get; set; } = DefaultTypeValueComponents;

    /// <summary>
    /// A function that provides the children of a given object. By default it uses <see cref="DefaultChildrenProvider"/>, but you can override it.
    /// </summary>
    [Parameter]
    public Func<object, ICollection<object?>> ChildrenProvider { get; set; } = DefaultChildrenProvider;

    /// <summary>
    /// The display name for the root object.
    /// </summary>
    [Parameter]
    public string? DisplayName { get; set; }

    /// <summary>
    /// If to hide type names in the tree.
    /// </summary>
    [Parameter]
    public bool HideType { get; set; }

    /// <summary>
    /// Callback invoked when a type name is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<Type> OnTypeClick { get; set; }

    public Exception? Exception { get; private set; }

    public bool IsExpandable => Value is not null && Children.Any();

    public bool IsExpanded
    {
        get => expandedObjects.Contains(expandedObject);
        set
        {
            // Children.Any could be a bit expensive
            if (!value || !IsExpandable)
            {
                expandedObjects.Remove(expandedObject);
                return;
            }

            if (HasCyclicReference())
            {
                throw new InvalidOperationException("Detected cyclic reference in object tree");
            }

            expandedObjects.Add(expandedObject);
        }
    }

    /// <summary>
    /// Whether the root object is expanded by default.
    /// </summary>
    [Parameter]
    public bool IsExpandedByDefault { get; set; }

    private object? selectedObject;

    public object? SelectedObject 
    {
        get => ParentTree?.SelectedObject ?? selectedObject;
        private set
        {
            if (ParentTree is not null)
            {
                ParentTree.SelectedObject = value;
            }
            else
            {
                selectedObject = value;
            }
        }
    }

    [Parameter]
    public EventCallback<object?> SelectedObjectChanged { get; set; }

    public void ToggleExpanded()
    {
        try
        {
            IsExpanded = !IsExpanded;
        }
        catch (Exception ex)
        {
            Exception = ex;
        }
    }

    public ICollection<object?> Children => Value is null ? [] : ChildrenProvider(Value);

    protected override void OnInitialized()
    {
        IsExpanded = IsExpandedByDefault;
    }

    private static ICollection<object?> DefaultChildrenProvider(object parent)
    {
        Type parentType;

        try
        {
            switch (parent)
            {
                case ReuObjectTreeMember member:
                    var valueMember = member.Value;
                    if (valueMember is null) return [];
                    parentType = valueMember.GetType();
                    parent = valueMember;
                    break;
                case ReuObjectTreeItem item:
                    var valueItem = item.Value;
                    if (valueItem is null) return [];
                    parentType = valueItem.GetType();
                    parent = valueItem;
                    break;
                case ReuObjectTreeKeyValue keyValue:
                    var valueKeyValue = keyValue.Value;
                    if (valueKeyValue is null) return [];
                    parentType = valueKeyValue.GetType();
                    parent = valueKeyValue;
                    break;
                default:
                    parentType = parent.GetType();
                    break;
            }
        }
        catch (TargetInvocationException)
        {
            return [];
        }

        if (parent is string)
        {
            return [];
        }

        var isCollection = parent is System.Collections.ICollection or IReadOnlyCollection<object?>;

        var hasCapacity = false;
        if (parentType.IsGenericType)
        {
            var genericDef = parentType.GetGenericTypeDefinition();
            hasCapacity = genericDef == typeof(List<>) || genericDef == typeof(Dictionary<,>);
        }

        var isDictionary = parent is System.Collections.IDictionary;

        var list = new List<object?>();

        if (!parentType.IsArray)
        {
            foreach (var prop in parentType.GetProperties().OrderBy(x => x.Name))
            {
                if (prop.GetIndexParameters().Length > 0)
                {
                    continue;
                }

                if (isDictionary && prop.Name is "Keys" or "Values" or "Comparer")
                {
                    continue;
                }

                if (isCollection && prop.Name == "Count")
                {
                    continue;
                }

                if (hasCapacity && prop.Name == "Capacity")
                {
                    continue;
                }

                list.Add(new ReuObjectTreeMember(parent, prop));
            }
        }

        switch (parent)
        {
            case System.Collections.IDictionary dictionary:
                foreach (var key in dictionary.Keys)
                {
                    list.Add(new ReuObjectTreeKeyValue(parent, key, dictionary[key]));
                }
                break;
            case IEnumerable<object?> enumerable:
                var index = 0;
                foreach (var item in enumerable)
                {
                    list.Add(new ReuObjectTreeItem(parent, index, item));
                    index++;
                }
                break;
        }

        return list;
    }

    private bool HasCyclicReference()
    {
        try
        {
            if (Value is not ReuObjectTreeMember currentMember)
            {
                return false;
            }

            while (Parent is ReuObjectTreeMember parentMember)
            {
                if (Equals(currentMember.Value, parentMember.Value))
                {
                    return true;
                }

                Parent = parentMember.Parent;
            }
        }
        catch (TargetInvocationException)
        {
        }

        return false;
    }

    private async Task OnValueChange(object? newValue)
    {
        // this ensures the parent object is also updated (only 1 layer up to maintain performance, but in most cases it is ok)
        if (ParentTree is null)
        {
            Update();
        }
        else
        {
            ParentTree.Update();
        }
    }

    /// <summary>
    /// Updates the state of the tree and its children (not the parent trees).
    /// </summary>
    public void Update()
    {
        StateHasChanged();
    }

    /// <summary>
    /// Updates the state of the root tree and all its children.
    /// </summary>
    public void UpdateAll()
    {
        if (ParentTree is null)
        {
            Update();
            return;
        }

        var rootTree = ParentTree;
        while (rootTree.ParentTree is not null)
        {
            rootTree = rootTree.ParentTree;
        }
        rootTree.Update();
    }

    private async Task SelectAsync(object? obj)
    {
        if (SelectedObject?.Equals(obj) == true)
        {
            SelectedObject = null;
        }
        else
        {
            SelectedObject = obj;
        }

        UpdateAll();

        await SelectedObjectChanged.InvokeAsync(SelectedObject);
    }

    public static Dictionary<Type, Type> DefaultTypeComponents { get; } = new()
    {
        [typeof(ReuObjectTreeMember)] = typeof(ReuObjectTreeMemberTypeComponent),
        [typeof(ReuObjectTreeItem)] = typeof(ReuObjectTreeItemTypeComponent),
        [typeof(ReuObjectTreeKeyValue)] = typeof(ReuObjectTreeKeyValueTypeComponent),
    };

    public static Dictionary<Type, Type> DefaultTypeValueComponents { get; } = new()
    {
        [typeof(string)] = typeof(StringTypeValueComponent),
        //[typeof(DateTime)] = typeof(DateTimeTypeValueComponent), not great yet
        [typeof(TimeSpan)] = typeof(TimeSpanTypeValueComponent),
        [typeof(Enum)] = typeof(EnumTypeValueComponent),
        [typeof(bool)] = typeof(BooleanTypeValueComponent),
        [typeof(sbyte)] = typeof(SByteTypeValueComponent),
        [typeof(byte)] = typeof(ByteTypeValueComponent),
        [typeof(short)] = typeof(Int16TypeValueComponent),
        [typeof(int)] = typeof(Int32TypeValueComponent),
        [typeof(long)] = typeof(Int64TypeValueComponent),
        [typeof(ushort)] = typeof(UInt16TypeValueComponent),
        [typeof(uint)] = typeof(UInt32TypeValueComponent),
        [typeof(ulong)] = typeof(UInt64TypeValueComponent),
        [typeof(float)] = typeof(SingleTypeValueComponent),
        [typeof(double)] = typeof(DoubleTypeValueComponent),
        [typeof(decimal)] = typeof(DecimalTypeValueComponent),
        [typeof(Guid)] = typeof(GuidTypeValueComponent),
    };

    // This object cannot be record type as it needs to be unique for ALL instances
    private sealed class ExpandedObject;
}