<div>
    <div class="item">
        @if (Value is null)
        {
            @NullFormat
        }
        else if (TypeComponents.TryGetValue(Value.GetType(), out var componentType))
        {
            var parameters = new Dictionary<string, object>
            {
                ["Value"] = Value,
                ["TypeValueComponents"] = TypeValueComponents,
                ["IsExpandable"] = IsExpandable,
                ["IsExpanded"] = IsExpanded,
                ["OnExpandToggle"] = EventCallback.Factory.Create(this, ToggleExpanded),
                ["ShowType"] = ShowType,
                ["ValueChanged"] = EventCallback.Factory.Create(this, StateHasChanged) // this will not update the parent object just yet, which could be affected as well
            };

            <DynamicComponent Type="componentType" Parameters="parameters" />
        }
        else
        {
            <div class="box">@(DisplayName ?? Value.ToString())</div>

            @if (IsExpandable)
            {
                <div @onclick="ToggleExpanded" class="box general expander">
                    @(IsExpanded ? "▼" : "▶")
                </div>
            }
        }

        @if (Exception is not null)
        {
            <div style="color: red;">@Exception.Message</div>
        }
    </div>
    @if (IsExpanded && Children.Any())
    {
        <div class="items">
            @foreach (var child in Children)
            {
                <ReuObjectTree Parent="Value" Value="child" TypeComponents="TypeComponents" TypeValueComponents="TypeValueComponents" NullFormat="NullFormat" ChildrenProvider="ChildrenProvider"></ReuObjectTree>
            }
        </div>
    }
</div>

@code {
    private static HashSet<ExpandedObject> expandedObjects = new();
    private static HashSet<object> expansionPath = new();

    private ExpandedObject expandedObject = new();

    [Parameter, EditorRequired]
    public object? Value { get; set; }

    /// <summary>
    /// Tracks the parent object of the current <see cref="Value"/>. Do not set unless you know what you are doing.
    /// </summary>
    [Parameter]
    public object? Parent { get; set; }

    [Parameter, EditorRequired]
    public RenderFragment NullFormat { get; set; } = default!;

    [Parameter]
    public Dictionary<Type, Type> TypeComponents { get; set; } = DefaultTypeComponents;

    [Parameter]
    public Dictionary<Type, Type> TypeValueComponents { get; set; } = DefaultTypeValueComponents;

    [Parameter]
    public Func<object, ICollection<object?>> ChildrenProvider { get; set; } = DefaultChildrenProvider;

    [Parameter]
    public string? DisplayName { get; set; }

    public Exception? Exception { get; private set; }

    public bool ShowType { get; set; } = true;

    public bool IsExpandable => Value is not null && Children.Any();

    public bool IsExpanded
    {
        get => expandedObjects.Contains(expandedObject);
        set
        {
            // Children.Any could be a bit expensive
            if (!value || !IsExpandable)
            {
                expandedObjects.Remove(expandedObject);
                return;
            }

            if (HasCyclicReference())
            {
                throw new InvalidOperationException("Detected cyclic reference in object tree");
            }

            expandedObjects.Add(expandedObject);
        }
    }

    public void ToggleExpanded()
    {
        try
        {
            IsExpanded = !IsExpanded;
        }
        catch (Exception ex)
        {
            Exception = ex;
        }
    }

    public ICollection<object?> Children => Value is null ? [] : ChildrenProvider(Value);

    private static ICollection<object?> DefaultChildrenProvider(object parent)
    {
        Type parentType;

        switch (parent)
        {
            case ReuObjectTreeMember member:
                var valueMember = member.Value;
                if (valueMember is null) return [];
                parentType = valueMember.GetType();
                parent = valueMember;
                break;
            case ReuObjectTreeItem item:
                var valueItem = item.Value;
                if (valueItem is null) return [];
                parentType = valueItem.GetType();
                parent = valueItem;
                break;
            default:
                parentType = parent.GetType();
                break;
        }

        var list = new List<object?>();

        foreach (var prop in parentType.GetProperties().OrderBy(x => x.Name))
        {
            if (prop.GetIndexParameters().Length > 0)
            {
                continue;
            }

            list.Add(new ReuObjectTreeMember(parent, prop));
        }

        if (parent is IEnumerable<object?> enumerable)
        {
            var index = 0;
            foreach (var item in enumerable)
            {
                list.Add(new ReuObjectTreeItem(parent, index, item));
                index++;
            }
        }

        return list;
    }

    private bool HasCyclicReference()
    {
        if (Value is not ReuObjectTreeMember currentMember)
        {
            return false;
        }

        while (Parent is ReuObjectTreeMember parentMember)
        {
            if (Equals(currentMember.Value, parentMember.Value))
            {
                return true;
            }

            Parent = parentMember.Parent;
        }

        return false;
    }

    public static Dictionary<Type, Type> DefaultTypeComponents { get; } = new()
    {
        [typeof(ReuObjectTreeMember)] = typeof(ReuObjectTreeMemberTypeComponent),
        [typeof(ReuObjectTreeItem)] = typeof(ReuObjectTreeItemTypeComponent),
    };

    public static Dictionary<Type, Type> DefaultTypeValueComponents { get; } = new()
    {
        [typeof(int)] = typeof(Int32TypeValueComponent),
        [typeof(string)] = typeof(StringTypeValueComponent),
        [typeof(DateTime)] = typeof(DateTimeTypeValueComponent),
        [typeof(Enum)] = typeof(EnumTypeValueComponent),
    };

    // This object cannot be record type as it needs to be unique for ALL instances
    private sealed class ExpandedObject;
}