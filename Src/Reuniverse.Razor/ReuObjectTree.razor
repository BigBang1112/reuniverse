<div>
    <div class="item">
        @if (Value is null)
        {
            <span class="box-value">null</span>
        }
        else if (TypeComponents.TryGetValue(Value.GetType(), out var componentType))
        {
            var parameters = new Dictionary<string, object>
            {
                ["Value"] = Value,
                ["TypeValueComponents"] = TypeValueComponents,
                ["IsExpandable"] = IsExpandable,
                ["IsExpanded"] = IsExpanded,
                ["OnExpandToggle"] = EventCallback.Factory.Create(this, ToggleExpanded),
                ["HideType"] = HideType,
                ["OnTypeClick"] = OnTypeClick,
                ["ValueChanged"] = EventCallback.Factory.Create(this, StateHasChanged) // this will not update the parent object just yet, which could be affected as well
            };

            <DynamicComponent Type="componentType" Parameters="parameters" />
        }
        else
        {
            <div class="box">@(DisplayName ?? Value.ToString())</div>

            @if (IsExpandable)
            {
                <div @onclick="ToggleExpanded" class="box general expander @(IsExpanded ? "active" : "")">
                    @(IsExpanded ? "▼" : "▶")
                </div>
            }
        }

        @if (Exception is not null)
        {
            <div style="color: var(--color-red);">@Exception.Message</div>
        }
    </div>
    @if (IsExpanded && Children.Any())
    {
        <div class="items">
            @foreach (var child in Children)
            {
                <ReuObjectTree Parent="Value"
                               Value="child"
                               HideType="HideType"
                               OnTypeClick="OnTypeClick"
                               TypeComponents="TypeComponents"
                               TypeValueComponents="TypeValueComponents"
                               ChildrenProvider="ChildrenProvider"></ReuObjectTree>
            }
        </div>
    }
</div>

@code {
    private static HashSet<ExpandedObject> expandedObjects = new();
    private static HashSet<object> expansionPath = new();

    private ExpandedObject expandedObject = new();

    /// <summary>
    /// The object to display.
    /// </summary>
    [Parameter, EditorRequired]
    public object? Value { get; set; }

    /// <summary>
    /// Tracks the parent object of the current <see cref="Value"/>. Do not set unless you know what you are doing.
    /// </summary>
    [Parameter]
    public object? Parent { get; set; }

    [Parameter]
    public Dictionary<Type, Type> TypeComponents { get; set; } = DefaultTypeComponents;

    [Parameter]
    public Dictionary<Type, Type> TypeValueComponents { get; set; } = DefaultTypeValueComponents;

    [Parameter]
    public Func<object, ICollection<object?>> ChildrenProvider { get; set; } = DefaultChildrenProvider;

    /// <summary>
    /// The display name for the root object.
    /// </summary>
    [Parameter]
    public string? DisplayName { get; set; }

    /// <summary>
    /// If to hide type names in the tree.
    /// </summary>
    [Parameter]
    public bool HideType { get; set; }

    /// <summary>
    /// Callback invoked when a type name is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<Type> OnTypeClick { get; set; }

    public Exception? Exception { get; private set; }

    public bool IsExpandable => Value is not null && Children.Any();

    public bool IsExpanded
    {
        get => expandedObjects.Contains(expandedObject);
        set
        {
            // Children.Any could be a bit expensive
            if (!value || !IsExpandable)
            {
                expandedObjects.Remove(expandedObject);
                return;
            }

            if (HasCyclicReference())
            {
                throw new InvalidOperationException("Detected cyclic reference in object tree");
            }

            expandedObjects.Add(expandedObject);
        }
    }

    /// <summary>
    /// Whether the root object is expanded by default.
    /// </summary>
    [Parameter]
    public bool IsExpandedByDefault { get; set; }

    public void ToggleExpanded()
    {
        try
        {
            IsExpanded = !IsExpanded;
        }
        catch (Exception ex)
        {
            Exception = ex;
        }
    }

    public ICollection<object?> Children => Value is null ? [] : ChildrenProvider(Value);

    protected override void OnInitialized()
    {
        IsExpanded = IsExpandedByDefault;
    }

    private static ICollection<object?> DefaultChildrenProvider(object parent)
    {
        Type parentType;

        switch (parent)
        {
            case ReuObjectTreeMember member:
                var valueMember = member.Value;
                if (valueMember is null) return [];
                parentType = valueMember.GetType();
                parent = valueMember;
                break;
            case ReuObjectTreeItem item:
                var valueItem = item.Value;
                if (valueItem is null) return [];
                parentType = valueItem.GetType();
                parent = valueItem;
                break;
            default:
                parentType = parent.GetType();
                break;
        }

        var list = new List<object?>();

        foreach (var prop in parentType.GetProperties().OrderBy(x => x.Name))
        {
            if (prop.GetIndexParameters().Length > 0)
            {
                continue;
            }

            list.Add(new ReuObjectTreeMember(parent, prop));
        }

        if (parent is IEnumerable<object?> enumerable)
        {
            var index = 0;
            foreach (var item in enumerable)
            {
                list.Add(new ReuObjectTreeItem(parent, index, item));
                index++;
            }
        }

        return list;
    }

    private bool HasCyclicReference()
    {
        if (Value is not ReuObjectTreeMember currentMember)
        {
            return false;
        }

        while (Parent is ReuObjectTreeMember parentMember)
        {
            if (Equals(currentMember.Value, parentMember.Value))
            {
                return true;
            }

            Parent = parentMember.Parent;
        }

        return false;
    }

    public static Dictionary<Type, Type> DefaultTypeComponents { get; } = new()
    {
        [typeof(ReuObjectTreeMember)] = typeof(ReuObjectTreeMemberTypeComponent),
        [typeof(ReuObjectTreeItem)] = typeof(ReuObjectTreeItemTypeComponent),
    };

    public static Dictionary<Type, Type> DefaultTypeValueComponents { get; } = new()
    {
        [typeof(string)] = typeof(StringTypeValueComponent),
        //[typeof(DateTime)] = typeof(DateTimeTypeValueComponent), not great yet
        [typeof(TimeSpan)] = typeof(TimeSpanTypeValueComponent),
        [typeof(Enum)] = typeof(EnumTypeValueComponent),
        [typeof(bool)] = typeof(BooleanTypeValueComponent),
        [typeof(sbyte)] = typeof(SByteTypeValueComponent),
        [typeof(byte)] = typeof(ByteTypeValueComponent),
        [typeof(short)] = typeof(Int16TypeValueComponent),
        [typeof(int)] = typeof(Int32TypeValueComponent),
        [typeof(long)] = typeof(Int64TypeValueComponent),
        [typeof(ushort)] = typeof(UInt16TypeValueComponent),
        [typeof(uint)] = typeof(UInt32TypeValueComponent),
        [typeof(ulong)] = typeof(UInt64TypeValueComponent),
        [typeof(float)] = typeof(SingleTypeValueComponent),
        [typeof(double)] = typeof(DoubleTypeValueComponent),
        [typeof(decimal)] = typeof(DecimalTypeValueComponent),
        [typeof(Guid)] = typeof(GuidTypeValueComponent),
    };

    // This object cannot be record type as it needs to be unique for ALL instances
    private sealed class ExpandedObject;
}